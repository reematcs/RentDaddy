name: AWS Deploy

on:
  push:
    branches:
      - main
  workflow_dispatch:

env:
  AWS_REGION: us-east-2
  AWS_ACCOUNT_ID: ${{ secrets.AWS_ACCOUNT_ID }}
  BACKEND_SECRET_ARN: ${{ secrets.BACKEND_SECRET_ARN }}
  DOCUMENSO_SECRET_ARN: ${{ secrets.DOCUMENSO_SECRET_ARN }}

jobs:
  terraform:
    name: Deploy Infrastructure
    runs-on: ubuntu-latest
    environment: production
    
    steps:
      - uses: actions/checkout@v4
      
      - name: Configure AWS Credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ env.AWS_REGION }}
      
      - name: Setup Terraform
        uses: hashicorp/setup-terraform@v3
        with:
          terraform_version: "1.5.0"
      
      - name: Terraform Init
        working-directory: ./deployment/simplified_terraform
        run: terraform init
      
      - name: Terraform Plan
        working-directory: ./deployment/simplified_terraform
        run: |
          terraform plan \
            -var="aws_account_id=${{ env.AWS_ACCOUNT_ID }}" \
            -var="backend_secret_arn=${{ env.BACKEND_SECRET_ARN }}" \
            -var="documenso_secret_arn=${{ env.DOCUMENSO_SECRET_ARN }}" \
            -out=tfplan
      
      - name: Terraform Apply
        working-directory: ./deployment/simplified_terraform
        if: github.event_name == 'push' || github.event.inputs.deploy == 'true'
        run: |
          terraform apply -auto-approve tfplan

  build-and-deploy:
    name: Build and Deploy Applications
    runs-on: ubuntu-latest
    needs: terraform
    environment: production
    
    steps:
      - uses: actions/checkout@v4
      
      - name: Configure AWS Credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ env.AWS_REGION }}
      
      - name: Login to Amazon ECR
        id: login-ecr
        uses: aws-actions/amazon-ecr-login@v2
      
      - name: Build and Push Backend
        env:
          ECR_REGISTRY: ${{ steps.login-ecr.outputs.registry }}
          IMAGE_TAG: ${{ github.sha }}
        run: |
          # Create .env file for build
          cat > backend/.env.production.local << EOF
          POSTGRES_PASSWORD=${{ secrets.POSTGRES_PASSWORD }}
          CLERK_SECRET_KEY=${{ secrets.CLERK_SECRET_KEY }}
          CLERK_WEBHOOK=${{ secrets.CLERK_WEBHOOK }}
          SMTP_USER=${{ secrets.SMTP_USER }}
          SMTP_PASSWORD=${{ secrets.SMTP_PASSWORD }}
          DOCUMENSO_API_KEY=${{ secrets.DOCUMENSO_API_KEY }}
          DOCUMENSO_WEBHOOK_SECRET=${{ secrets.DOCUMENSO_WEBHOOK_SECRET }}
          PG_URL=${{ secrets.PG_URL }}
          # Add other secrets as needed
          EOF
          
          cd backend
          docker build -t $ECR_REGISTRY/rentdaddy/backend:$IMAGE_TAG -f Dockerfile.prod .
          docker tag $ECR_REGISTRY/rentdaddy/backend:$IMAGE_TAG $ECR_REGISTRY/rentdaddy/backend:latest
          docker push $ECR_REGISTRY/rentdaddy/backend:$IMAGE_TAG
          docker push $ECR_REGISTRY/rentdaddy/backend:latest
      
      - name: Build and Push Frontend
        env:
          ECR_REGISTRY: ${{ steps.login-ecr.outputs.registry }}
          IMAGE_TAG: ${{ github.sha }}
        run: |
          # Create .env file for build
          cat > frontend/app/.env.production.local << EOF
          VITE_CLERK_PUBLISHABLE_KEY=${{ vars.VITE_CLERK_PUBLISHABLE_KEY }}
          VITE_BACKEND_URL=${{ vars.VITE_BACKEND_URL }}
          VITE_PORT=${{ vars.VITE_PORT }}
          VITE_DOMAIN_URL=${{ vars.VITE_DOMAIN_URL }}
          VITE_DOCUMENSO_PUBLIC_URL=${{ vars.VITE_DOCUMENSO_PUBLIC_URL }}
          VITE_SERVER_URL=${{ vars.VITE_SERVER_URL }}
          VITE_ENV=production
          EOF
          
          cd frontend/app
          docker build -t $ECR_REGISTRY/rentdaddy/frontend:$IMAGE_TAG -f Dockerfile.prod .
          docker tag $ECR_REGISTRY/rentdaddy/frontend:$IMAGE_TAG $ECR_REGISTRY/rentdaddy/frontend:prod
          docker push $ECR_REGISTRY/rentdaddy/frontend:$IMAGE_TAG
          docker push $ECR_REGISTRY/rentdaddy/frontend:prod
      
      - name: Force ECS Deployment
        run: |
          aws ecs update-service \
            --cluster rentdaddy-cluster \
            --service rentdaddy-app-service \
            --force-new-deployment
          
          aws ecs update-service \
            --cluster rentdaddy-cluster \
            --service rentdaddy-documenso-service \
            --force-new-deployment
      
      - name: Wait for Deployment
        timeout-minutes: 10
        run: |
          echo "Waiting for services to stabilize..."
          aws ecs wait services-stable \
            --cluster rentdaddy-cluster \
            --services rentdaddy-app-service rentdaddy-documenso-service
      
      - name: Verify Deployment
        run: |
          echo "Checking service health..."
          
          # Check frontend
          response=$(curl -s -o /dev/null -w "%{http_code}" https://app.curiousdev.net -m 10)
          if [ "$response" != "200" ]; then
            echo "Frontend health check failed with status $response"
            exit 1
          fi
          echo "✅ Frontend is healthy"
          
          # Check API
          response=$(curl -s -o /dev/null -w "%{http_code}" https://api.curiousdev.net/healthz -m 10)
          if [ "$response" != "200" ]; then
            echo "API health check failed with status $response"
            exit 1
          fi
          echo "✅ API is healthy"
          
          # Check Documenso (expecting 307 redirect)
          response=$(curl -s -o /dev/null -w "%{http_code}" https://docs.curiousdev.net -m 10)
          if [[ "$response" != "3"* ]]; then
            echo "Documenso health check failed with status $response"
            exit 1
          fi
          echo "✅ Documenso is healthy"